<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Coin toss markov chains</title>
  <meta name="description" content="1. The question Let’s start with a simple question that will motivate the content of this blog. Not only is the answer beautiful, but it also helps us develo...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/jekyll/update/2018/10/07/competitive_coin_tossing.html">
  <link rel="alternate" type="application/rss+xml" title="Musings on Math (++)" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Musings on Math (++)</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Coin toss markov chains</h1>
    <p class="post-meta"><time datetime="2018-10-08T05:02:40+02:00" itemprop="datePublished">Oct 7, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="1-the-question">1. The question</h2>
<p>Let’s start with a simple question that will motivate the content of this blog. Not only is the answer beautiful, 
but it also helps us develop a framework for answering a whole family of such questions. The question goes like this - 
let’s say I have a fair coin (50-50 chance of heads and tails) and so do you. Both of us start tossing our coins. 
What is the probability that you will get three heads in a row before I get two heads in a row? 
It’s quite clear that I have a higher chance of winning (but don’t worry,
my better odds are balanced by us obsessing over your victory throughout this post). 
Now, how do we go about calculating how much higher?</p>

<h2 id="2-thinking-in-terms-of-states">2. Thinking in terms of states</h2>
<p>We can think of how close each player is to realizing his goal in terms of states. The first player (I) keeps tossing until he
reaches two consecutive heads. So, we can define his state after n tosses as the number of consecutive heads he has so far.
In the beginning, there are no tosses. So, the number of consecutive heads at that point is obviously zero.</p>

<p>If he gets a heads on the first toss then the number of consecutive heads after the first toss is one whereas if he gets
a tails, it stays at zero. Hence, anytime a player is in the state “zero consecutive heads”, there is a 50% chance they will
go to one consecutive head and 50% chance they will stay at zero consecutive heads after the next toss. The probability that 
the player will jump from zero consecutive heads to two consecutive heads in one toss is zero.</p>

<p>We can collect these three numbers into a vector of probabilities.</p>

<script type="math/tex; mode=display">v = (.5, .5, 0)</script>

<p>Similarly, if a player is at one consecutive head so far on any toss, the probability that they will be at two consecutive heads
after the next toss is 50% and the probability of dropping back to zero is 50%. There will be a vector for transitions from this
state as well.</p>

<p>So, each state has a vector of probabilities of going to each of the other states. We can collect these vectors and create a matrix.</p>

<p>This is what it will look like for me:</p>

<script type="math/tex; mode=display">% <![CDATA[
M_3 = \left( \begin{array}{ccc}
		0.5 & 0.5 & 0 & \\
		0.5 & 0 & 0.5 \\
		0 & 0 & 1
		\end{array} \right) %]]></script>

<p>Note that the third row corresponds to the transitions from state 2. Since I plan on stopping once I reach two consecutive heads,
I will not be making transitions to any other states once I reach state 2. That’s why state 2 (third row) has a probability 1 of
simply transitioning to itself.</p>

<p>Similarly, you plan on stopping once you reach three consecutive heads. So, your transition matrix will look like this:</p>

<script type="math/tex; mode=display">% <![CDATA[
M_4 = \left( \begin{array}{ccc}
		0.5 & 0.5 & 0 & 0 & \\
		0.5 & 0 & 0.5 & 0\\
		0.5 & 0 & 0 & 0.5\\
		0 & 0 & 0 & 1
		\end{array} \right) %]]></script>

<h2 id="3-probabilities-at-nth-toss">3. Probabilities at nth toss</h2>
<p>Now, let’s think of the probabilities that I am in each of the possible states after a certain number of tosses. As said before,
the probabilities at zero tosses are pretty clear. Both sequences are at zero consecutive heads. For the first sequence for example,
there is a 100% chance I’m in state 0, a 0% chance I’m in state one (one consecutive head) and 0% chance I’m in state two. These three
probabilities can be collected into a vector:</p>

<script type="math/tex; mode=display">P_0 = (1, 0, 0)</script>

<p>Now, what about after one toss. If I get a heads, I go to state one and stay in state zero if I get a tails. In other words, there
is a 50-50 chance I’ll be in state 0 or state 1 after the first toss.</p>

<script type="math/tex; mode=display">P_1 = (0.5, 0.5, 0)</script>

<p>This argument might give you a feeling of deja-vu since we used the exact same one when constructing the matrix <script type="math/tex">M_3</script>. In fact, we can get <script type="math/tex">P_1</script>
by simply multiplying the <script type="math/tex">P_0</script> with <script type="math/tex">M_3</script>.</p>

<script type="math/tex; mode=display">% <![CDATA[
P_0 M_3 = (1,0,0) \left( \begin{array}{ccc}
		0.5 & 0.5 & 0 & \\
		0.5 & 0 & 0.5 \\
		0 & 0 & 1
		\end{array} \right) = (.5,.5,0) = P_1 %]]></script>

<p>Similarly to get <script type="math/tex">P_2</script>, we multiply <script type="math/tex">P_1</script> with <script type="math/tex">M_3</script>.</p>

<script type="math/tex; mode=display">% <![CDATA[
P_1 M_3 = (.5,.5,0) \left( \begin{array}{ccc}
		0.5 & 0.5 & 0 & \\
		0.5 & 0 & 0.5 \\
		0 & 0 & 1
		\end{array} \right) = (.5,.25,.25) = P_2 %]]></script>

<p>Which means that after 2 tosses, there is a .25 probability that I would reach my goal.</p>

<p>But from the previous equation we can say,</p>

<script type="math/tex; mode=display">P_2 = P_1 M_3 = P_0 M_3 M_3 = P_0 M_3^2</script>

<p>In general we can say,</p>

<script type="math/tex; mode=display">\begin{equation} P_n = P_0 M_3^n \tag{1}\end{equation}</script>

<p>Now, we can of course say this for any transition probability matrix <script type="math/tex">M</script> (non-negative entries and rows sum to one).</p>

<p>For your markov chain (you need three consecutive heads) we can similarly define the probabilities <script type="math/tex">Q_n</script>, that you will be in 
each of the states 0, 1, 2 and your goal state of 3 consecutive heads. Like before,</p>

<script type="math/tex; mode=display">\begin{equation} Q_n = Q_0 M_4^n \tag{2}\end{equation}</script>

<p><script type="math/tex">Q_0</script> is your state at zero tosses which is <script type="math/tex">(1,0,0,0)</script> (with a probability of one, you are in state 0 - you haven’t tossed,
so have obtained zero consecutive heads so far).</p>

<p>Let’s plot the probabilities that you will be in each of the states as a function of <script type="math/tex">n</script>.</p>

<p><img src="http://localhost:4000/Downloads/CompetitiveCoinToss/probs_seq.png" alt="Probability sequences" /></p>

<p>In the beginning, the starting state (0 consecutive heads) is obviously at 1.0. But it soon drops to zero. The other two non-absorbing states also make a climb initially since the final absorbing state must go through them. However, they quickly fall to zero as all the probability
mass is sucked up by the absorbing state (in green).</p>

<p>Here is some simple, self-contained python code that shows how to calculate the probabilities of this sequence getting to the absorbing state as a function of the
number of tosses (the green line in the plot).</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># The transition matrix.</span>
<span class="n">m_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([</span>
	 <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
	 <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">],</span>
	 <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
	 <span class="p">])</span>

<span class="c">## Probabilities of getting to absorbing state after n tosses.</span>
<span class="c"># First raise the matrix to nth power</span>
<span class="c"># then get the index of absorbing state</span>
<span class="n">p_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m_3</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>\
						 <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>\
                               <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)])</span><span class="c">#Calculate this upto 100 tosses.</span>
</code></pre>
</div>

<p>The plot will look very similar for the elements of the vector <script type="math/tex">P_n</script> of my states. However, my absorbing state (two consecutive heads)
will be reached much quicker. In fact, let’s compare the probabilities me and you reach our goals (absorbing states: 2 heads and 3 heads respectively) 
by plotting them side-by-side.</p>

<p><img src="http://localhost:4000/Downloads/CompetitiveCoinToss/probs_two_chains.png" alt="Probability sequences" /></p>

<h2 id="4-using-the-sequences-to-get-the-answer">4. Using the sequences to get the answer</h2>

<p>All this is well and good but how is it going to help us get the number we’re looking for? What is the probability that you will
reach three consecutive heads before I reach two? Let’s call this event <script type="math/tex">A</script>. We then want to calculate <script type="math/tex">P(A)</script> (probability of event <script type="math/tex">A</script>).</p>

<p>Since we have the probabilities of both sequences being in each state, <script type="math/tex">P_n</script> and <script type="math/tex">Q_n</script>, let’s try and use those. We can start with
thinking of the event where we win in the nth toss. Let’s call this event <script type="math/tex">A_n</script>. The only way <script type="math/tex">A</script> will happen is that one of the <script type="math/tex">A_n</script>s happen.</p>

<p>So, we can say that event <script type="math/tex">A</script> is the union of the events represented by <script type="math/tex">A_n</script>.</p>

<script type="math/tex; mode=display">A = \bigcup_{n=1}^{\infty}A_n</script>

<p>Also, the <script type="math/tex">A_n</script>’s are mutually exclusive (meaning you can’t win on the third toss <strong>and</strong> the fourth toss). Because of this we can say:</p>

<script type="math/tex; mode=display">P(A) = \sum_{n=1}^{\infty}P(A_n)</script>

<p>So, if we get <script type="math/tex">A_n</script>’s, we can sum them to get the probability we are interested in.</p>

<p>What needs to happen for you to win on the nth toss?</p>

<p>1) The losing sequence (mine), given by <script type="math/tex">P_n</script> should not have reached it’s absorbing state by the nth toss. Otherwise, you <strong>didn’t</strong> reach
three consecutive heads before I reached two. The probability is <script type="math/tex">(1-P_n[2])</script>.</p>

<p>2) The winning sequence (yours), given by <script type="math/tex">Q_n</script> should have reached a state where it needs just one more heads to win in the toss <em>one earlier than</em>
the current toss. In this case, it means I should have reached two consecutive heads by the <script type="math/tex">(n-1)</script>th toss. The probability is <script type="math/tex">Q_{n-1}[2]</script>.</p>

<p>3) And finally, you should get a heads in the <script type="math/tex">n</script>th toss and complete the coup-de-grace. The probability of this is <script type="math/tex">\frac{1}{2}</script> since the coins are fair.</p>

<p>Combining those three events, we get -</p>

<script type="math/tex; mode=display">P(A_n) = (1-P_n[2])(Q_{n-1}[2]) \frac{1}{2}</script>

<p>And so we get to the most important equation of this blog,</p>

<script type="math/tex; mode=display">\begin{equation}P(A) = \sum_{n=0}^{\infty} (1-P_n[2])(Q_{n-1}[2]) \frac{1}{2} \tag{3} \end{equation}</script>

<p>There are other ways to represent the equation above. Here, we considered that the probability of you winning on the <script type="math/tex">n</script>th toss should be: <script type="math/tex">\frac {Q_{n-1}[2]} {2}</script>. Taking it another way, we know that the probability that you will reach your goal on or before the <script type="math/tex">n</script>th toss is <script type="math/tex">Q_{n}[3]</script>. Also, the probability that you will reach your goal <em>on</em> the <script type="math/tex">n</script>th toss is the probability that you reach it on or before the <script type="math/tex">n</script>th toss subtracted by the probability that you reach it strictly before the <script type="math/tex">n</script>th toss, which is just <script type="math/tex">Q_{n}[3] - Q_{n-1}[3]</script>.</p>

<p>This means that equation (3) above can also be written as:</p>

<script type="math/tex; mode=display">P(A) = \sum_{n=0}^{\infty} (1-P_n[2])(Q_{n}[3]-Q_{n-1}[3])</script>

<p>We can get <script type="math/tex">P_n</script> and <script type="math/tex">Q_n</script> by using equations (1) and (2) and simply multiplying the transition matrices <script type="math/tex">n</script> times. Of course, the sum in equation (3) goes to infinite terms and we can’t multiply the matrices infinite times. However, note that (as we can see from figure 1), <script type="math/tex">(1-P_n[2])</script>
will tend to zero as <script type="math/tex">n</script> becomes large (as the absorbing state - which is 2 - sucks up all the probability mass as <script type="math/tex">n</script> increases 
and this means one minus it’s probability tends to zero) 
and <script type="math/tex">Q_{n-1}[2]</script> will tend
to zero for the same reason. So, the contributions to the sum of terms corresponding to large <script type="math/tex">n</script> become smaller and smaller. 
Hence, we can get a very, very good approximation by simply ignoring all terms associated with <script type="math/tex">n</script>s larger than some reasonable value (like 100 or 50).</p>

<p>Here is some python code that demonstrates <a href="https://gist.github.com/ryu577/89e4ef0b0b7fcba33e08a549f0793c86">this</a>.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">start1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">m_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">start2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">m_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="c"># p_n must always be one toss ahead of q_n_minus_1. So, when p_n is at toss 1, q_n_minus_1 </span>
<span class="c"># should be at 0. When it is at 2, q_n_minus_1 should be at 1 and so on.</span>
<span class="c"># that is why p_n starts with 1 and goes to 100 while q_n_minus_1 starts with 0 and goes to 99.</span>
<span class="n">p_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m_3</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>\
                                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">101</span><span class="p">)])</span>
<span class="n">q_n_minus_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m_4</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>\
                                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)])</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Prob(3 consec heads b4 2 consec heads):"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">q_n_minus_1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p_n</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</code></pre>
</div>

<p>Using this, we get that the probability we were after (you’ll get 3 consecitive heads before I get 2 consecutive heads) is <strong>21.25%</strong>.</p>

<p>Similarly by flipping things, we can get the probability that I’ll get 2 consecutive heads before you get 3 consecutive heads</p>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Assumes you have run the previous block</span>
<span class="n">p_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m_4</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">101</span><span class="p">)])</span>
<span class="n">q_n_minus_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m_3</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)])</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Prob(2 consec heads b4 3 consec heads):"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">q_n_minus_1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p_n</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</code></pre>
</div>
<p>This shows that the probability that I will win is <strong>73.98%</strong>.</p>

<p>Of course, the two numbers above don’t sum to one since there is also the third possibility of a draw (both reach their goals on the same toss).</p>

<p>We have now answered the question we posed at the starting of this blog. But often when one climbs to the top of a mountain, one 
simply sees more mountains on the other side. In that spirit, we will see what other questions we can answer with the tools developed
in seeking the answer to this one in the next section (5).</p>

<p>Also, note that the approach of taking a large sequence formed by repeated matrix multiplication is somewhat
ugly and inefficient. In section 6, we will improve on this and solve equation (3) in a cleaner, more efficient manner.</p>

<h2 id="5-other-mountains">5. Other mountains</h2>

<h3 id="51-even-the-odds">5.1. Even the odds</h3>
<p>In the question we started the blog with, it was clear that the stakes were in my favor.
Let’s consider now a contest where that isn’t obvious. I still need to get to two consecutive heads and you still need three.
But to even the odds for you, your heads no longer need to be consecutive. As soon as you see three heads in total, you win.</p>

<p>This turns out to be a pretty close contest. Who should a gambler bet their money on?</p>

<p>We can solve this problem in a pretty similar manner to the previous one. Just construct the two Markov chains, use them to calculate 
the sequences of being in their various states after <script type="math/tex">n</script> tosses and plug the sequences into equation (3). &amp;</p>

<p>My transition matrix will still be the <script type="math/tex">M_3</script> defined in section 2. Your transition matrix however, will not be the <script type="math/tex">M_4</script> defined there.</p>

<p>Now since you need three total heads, when you are in state <script type="math/tex">i</script>, you don’t go back to zero if you get a tail on that toss. Instead, you simply stay 
at the state you were. In this way, I’m penalized more severely for a tails (I have to start over and you don’t).</p>

<p>Your new transition matrix, <script type="math/tex">O_4</script> will look like this:</p>

<script type="math/tex; mode=display">% <![CDATA[
O_4 = \left( \begin{array}{cccc}
		0.5 & 0.5 & 0 & 0 & \\
		0 & 0.5 & 0.5 & 0\\
		0 & 0 & 0.5 & 0.5\\
		0 & 0 & 0 & 1
		\end{array} \right) %]]></script>

<p>And just like in section 4, we can solve this with the exact same code, just replacing your <script type="math/tex">M_4</script> matrix with <script type="math/tex">O_4</script> defined above.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">start1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">m_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">start2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">o_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="c"># See previous code block in section 4 for detailed comments.</span>
<span class="n">p_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m_3</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">101</span><span class="p">)])</span>
<span class="n">q_n_minus_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">o_4</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)])</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Prob(3 running heads b4 2 consec heads):"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">q_n_minus_1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p_n</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</code></pre>
</div>
<p>We see that the probability of you getting 3 running heads before my 2 consecutive is <strong>36.74%</strong>. Your chances of winning have improved
a little (from ~24% to ~37%), but there is more good news. When we flip things we get the probability that I will win:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Assumes you have run the previous block</span>
<span class="n">p_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">o_4</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">101</span><span class="p">)])</span>
<span class="n">q_n_minus_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">m_3</span><span class="p">,</span><span class="n">n</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)])</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Prob(2 consec heads b4 3 running heads):"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">q_n_minus_1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p_n</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</code></pre>
</div>

<p>And this turns out to be <strong>54.77%</strong>. So, my chances of winning have gone down from ~74% to ~55%. It seems there is a much higher chance 
the game will end in a draw (1-.55-.37 = 8%, up from 5% earlier).</p>

<p>So, your odds against me have gone from roughly 2:7 in the previous game to 2:3 in this one. That evens things out quite a bit, you’re probably still
not happy, so let’s see what else we can do.</p>

<h3 id="52-unfair-coins">5.2. Unfair coins</h3>
<p>In this section, we won’t settle for anything less than a completely even game. One way to do that is to go back to the old criterion (you need
three consecutive heads while I need 2). However, we’ll let you cheat and use a biased coin (one that has a higher probability of heads than mine).</p>

<p>So, while my head still has a 50% chance of getting heads, yours will be higher. If your coin has a 100% chance of getting heads, note that your win
is still not guaranteed. I could get heads on my first two tosses and that would mean you lose. The probability I’ll win is therefore 25% (<script type="math/tex">.5 \times .5</script> 
for the two heads I need).</p>

<p>The only way a draw can happen is if I get a tails on the first toss and then two consecutive heads. The probability of this is therefore 12.5% (<script type="math/tex">.5\times
.5 \times .5</script>).</p>

<p>So, the probability that you’ll win is 1-.125-.25 = 62.5%.</p>

<p>But that tips things too much in your favor. We want the game to be even. Also note that if your probability of winning is 50%, you’re still going to
be at an advantage because of the possibility of a draw, which will make my probability of winning less than 50%. We want to find the probability of
heads <script type="math/tex">p</script> your coin should have for none of us to have an advantage.</p>

<p>For this, we just need to wrap the code from the blocks above in a function that takes the probability of heads as input (instead of hard coding to 0.5)
and then we can a simple numeric method like bisection to find the <script type="math/tex">p</script> at which the probabilities of both of us winning are the same.</p>

<p>I simply plotted these probabilities with <script type="math/tex">p</script> in the code <a href="https://gist.github.com/ryu577/9464d39e1b40ffdd37773d44ffb81eab">here</a>. The result of which is:</p>

<p><img src="http://localhost:4000/Downloads/CompetitiveCoinToss/probs_with_p.png" alt="Probability sequences" /></p>

<p>You can see from the plot that at <script type="math/tex">p \sim 0.77</script> at which point, both of us will have a <script type="math/tex">\sim 45\%</script> chance of winning.</p>

<h3 id="53-longer-sequences">5.3. Longer sequences</h3>

<p>Now that we’ve evened the odds in the previous sub-section (just make your coin have a 77% instead of 50% chance of getting heads), 
we can try and test the power of these new wings we’ve developed. What if we go back to both of us having fair coins
and wanted to get the probability that I reach 4 consecutive heads before you reached 3? 
What if it were me reaching 5 before you reaching 4? In other words, you still require one more consecutive head than me, but we’re 
gradually increasing the number of heads I need. In general, what is the chance I’ll reach <script type="math/tex">n</script> heads before you reach <script type="math/tex">(n+1)</script> heads?</p>

<p>You can imagine now that the markov matrices become larger and larger as we increase <script type="math/tex">n</script> (there are <script type="math/tex">n^2</script> terms in the smaller one)
and the chance that the game is resolved by the hundredth toss will become smaller and smaller (two or three consecutive heads would have
appeared by the 100th toss, but ten consecutive heads is far less likely). So, we need to extend the sequences to a much larger number
of tosses.</p>

<p>This makes the method we described earlier very slow. But, we can still use the faster method referenced earlier (will be described in section 6)
to get the exact solution for <script type="math/tex">n</script> going all the way up to the late teens.</p>

<p>In any case, we plot the probabilities of me winning, you winning and a draw in the figure below. If you want to use the more efficient method 
described in section 6, you can do so with the aid of an open source library that goes along with this blog.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># To install the library, pip install stochproc from command line.</span>
<span class="c"># hosted at - https://github.com/ryu577/stochproc</span>
<span class="kn">from</span> <span class="nn">stochproc.competitivecointoss.smallmarkov</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span>
<span class="n">win_probs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
 	<span class="c"># The losing markov sequence of coin tosses that needs (n-1) heads.</span>
 	<span class="n">lose_seq</span> <span class="o">=</span> <span class="n">MarkovSequence</span><span class="p">(</span><span class="n">get_consecutive_heads_mat</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
 	<span class="c"># The winning markov sequence of coin tosses that needs n heads.</span>
 	<span class="n">win_seq</span> <span class="o">=</span> <span class="n">MarkovSequence</span><span class="p">(</span><span class="n">get_consecutive_heads_mat</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
 	<span class="c"># If you multiply the two sequence objects, you get the probability</span>
 	<span class="c"># that the first one beats the second one.</span>
	<span class="n">win_prob</span> <span class="o">=</span> <span class="n">win_seq</span><span class="o">*</span><span class="n">lose_seq</span>
	<span class="n">win_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_prob</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">win_probs</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="http://localhost:4000/Downloads/CompetitiveCoinToss/probs_with_n.png" alt="Probability sequences" /></p>

<p>Looking at the figure, something surprising pops out.</p>

<p>As we increase the number of tosses I need, the probability of you winning starts approaching 33.33% or one third.
Similarly, the probability of me winning starts approaching 66.67% or two thirds. It’s a little surprising that such simple numbers pop out.</p>

<p>And where there are simple numbers, there are elegant reasons.</p>

<p>Note that this game is like I have a coin that flips successfuly once in <script type="math/tex">2^n</script> (to get <script type="math/tex">n</script> heads in a row) and you have a coin that flips successfuly once in <script type="math/tex">2^{n+1}</script> and we ask who succeeds first.</p>

<p>What complicates matters is that I win ties. If <script type="math/tex">n</script> is large however, there will be very few ties.</p>

<p>Also if <script type="math/tex">n</script> is large, the chance of a run of <script type="math/tex">n</script> heads is very small, <script type="math/tex">2^{-n}</script>. We can view each flip as a try by you to start a run of <script type="math/tex">n+1</script> heads, which happens with probability <script type="math/tex">2^{-(n+1)}</script> and a try by me to start a run of <script type="math/tex">n</script> heads, which happens with probability <script type="math/tex">2^{-n}</script>.</p>

<p>Almost all attempts will fail for both of us. We can ignore those.</p>

<p>The chance that you win is then <script type="math/tex">\frac {2^{-(n+1)}}{2^{-n}+2^{-(n+1)}}= \frac{\frac 12}{1+ \frac12} = \frac 13</script>.</p>

<p>The reason it starts lower when <script type="math/tex">n</script> is smaller is that we might both start succesful runs at the same time, at which point you win because your run finishes first. However for large values of <script type="math/tex">n</script>, it becomes near impossible to succeed at the same time.</p>

<h2 id="6-closed-forming-the-markov-sequences">6. Closed forming the markov sequences</h2>

<p>In the previous section, the approximation of cutting off at 100 tosses worked pretty well. 
This is because there is a very high chance the game would have ended well before 100 tosses (either one of the players reaching their goal).</p>

<p>What if however, we wanted the probability the first player gets
50 consecutive heads before the second one got 51. The probability that this would get resolved before 100 tosses is quite low, so cutting off
at 100 would not give us a good approximation. And let’s say we needed to go to a million tosses to get a good approximation. Multiplying these 
large matrices millions of times would be a very computationally expensive affair to the point where we might not even be able to get the answer.</p>

<p>We can make this method more scalable to questions about large numbers of tosses and not dependent on multiplying matrices many times. 
But we’ll need some linear algebra - in particular, the concept of eigen decomposition - to do so.</p>

<p>To follow this section therefore, it is best you’re somewhat familiar with eigen value decomposition. It is basically a way to really x-ray matrices
and see what they’re all about. The idea is that for the matrices <script type="math/tex">M_3</script> and <script type="math/tex">M_4</script>, you can find three and four dimensional vectors respectively
that when multiplied with them, don’t change. And then there are other vectors that are also special because they change, but are only scaled, not rotated.</p>

<p>If the matrix is <script type="math/tex">n \times n</script>, you can find <script type="math/tex">n</script> such directions (including that one that wasn’t changed or was scaled by 1).</p>

<p>This translates to being able to write:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}M_3 E = E \left( \begin{array}{ccc}
		1 & 0 & 0 & \\
		0 & \lambda_1 & 0 \\
		0 & 0 & \lambda_2
		\end{array} \right) \tag{4}\end{equation} %]]></script>

<p>where the matrix <script type="math/tex">E</script> contains the special vectors that are scaled and not rotated as it’s columns.</p>

<p>Now if we look at equations (1) and (2), we basically need to raise the markov matrices to the power of <script type="math/tex">n</script>, meaning multiply them with themselves over and
over.</p>

<p>If we assume the matrix <script type="math/tex">E</script> from equation (4) is invertible, we can write (pre-multiplying both sides by <script type="math/tex">E^{-1}</script>).</p>

<script type="math/tex; mode=display">\begin{equation}M_3 = E \Lambda E^{-1}\tag{5}\end{equation}</script>

<p>Where</p>

<script type="math/tex; mode=display">% <![CDATA[
\Lambda = \left( \begin{array}{ccc}
		1 & 0 & 0 & \\
		0 & \lambda_1 & 0 \\
		0 & 0 & \lambda_2
		\end{array} \right) %]]></script>

<p>Now, if we want to square <script type="math/tex">M_3</script>, we can use equation (5)</p>

<script type="math/tex; mode=display">M_3^2 = E \Lambda E^{-1} E \Lambda E^{-1} = E \Lambda \Lambda E^{-1} = E \Lambda^2 E^{-1}</script>

<p>We can repeat this <script type="math/tex">n</script> times to conclude:</p>

<script type="math/tex; mode=display">M_3^n = E\Lambda^n E^{-1}</script>

<p>Since <script type="math/tex">\Lambda</script> is diagonal, we can write -</p>

<script type="math/tex; mode=display">% <![CDATA[
\Lambda^n = \left( \begin{array}{ccc}
		1 & 0 & 0 & \\
		0 & \lambda_1^n & 0 \\
		0 & 0 & \lambda_2^n
		\end{array} \right) %]]></script>

<p>Now from equation (1),</p>

<script type="math/tex; mode=display">P_n = P_0 M_3^n = (1,0,0) E \Lambda^n E^{-1}</script>

<p>If you multiply these out, this is equivalent to saying</p>

<script type="math/tex; mode=display">\begin{equation}P_n = (1,\lambda_1^n, \lambda_2^n) C \tag{6}\end{equation}</script>

<p>Where <script type="math/tex">C</script> is a constant matrix of coefficients given by:</p>

<script type="math/tex; mode=display">% <![CDATA[
C = \left( \begin{array}{ccc}
		E_{1,1} & 0 & 0 & \\
		0 & E_{1,2} & 0 \\
		0 & 0 & E_{1,3}
		\end{array} \right) E^{-1} %]]></script>

<p>and <script type="math/tex">E_{1,1}</script>, <script type="math/tex">E_{1,2}</script> and <script type="math/tex">E_{1,3}</script> are the elements of the first row of <script type="math/tex">E</script>.</p>

<p>In equation (3), we only need <script type="math/tex">P_n[2]</script> which will be given by:</p>

<script type="math/tex; mode=display">P_n[2] = C_{1,3}+C_{2,3}\lambda_1^n + C_{3,3} \lambda_2^n</script>

<p>You can see <a href="https://yutsumura.com/eigenvalues-of-a-stochastic-matrix-is-always-less-than-or-equal-to-1/">here</a> a proof that a stochastic matrix will always have eigen values less than one in magnitude.
This means that the second and third terms of the expression above will tend to zero as <script type="math/tex">n \to \infty</script>.</p>

<p>Since the sequence must eventually end up in the absorbing state for large enough <script type="math/tex">n</script> we must have,</p>

<script type="math/tex; mode=display">\lim_{n \to \infty} P_n[2] = C_{1,3} = 1</script>

<p>Giving us,</p>

<script type="math/tex; mode=display">\begin{equation}P_n[2] = 1 + C_{2,3}\lambda_1^n + C_{3,3}\lambda_2^n\tag{7}\end{equation}</script>

<p>Similarly, we will have a corresponding matrix <script type="math/tex">D</script> for your <script type="math/tex">Q_n</script> sequence and we can write:</p>

<script type="math/tex; mode=display">\begin{equation}Q_n[2] = 1 + D_{2,3}\mu_1^n+D_{3,3}\mu_2^n+D_{4,3}\mu_3^n\tag{8}\end{equation}</script>

<p>Plugging (7) and (8) into equation (3) we get,</p>

<script type="math/tex; mode=display">P(A) = \frac{1}{2}\sum_{n=1}^{\infty} (C_{2,3}\lambda_1^n + C_{3,3}\lambda_2^n)(1 + D_{2,3}\mu_1^{n-1}+D_{3,3}\mu_2^{n-1}+D_{4,3}\mu_3^{n-1})</script>

<script type="math/tex; mode=display">=\frac{1}{2}\sum_{n=1}^{\infty} (C_{2,3}\lambda_1^n + C_{3,3}\lambda_2^n)(1 + \frac{D_{2,3}}{\mu_1}\mu_1^{n}+\frac{D_{3,3}}{\mu_2}\mu_2^{n}+\frac{D_{4,3}}{\mu_3}\mu_3^{n})</script>

<script type="math/tex; mode=display">= \frac{1}{2}\left(C_{2,3}\left(\frac{\lambda_1}{1-\lambda_1}\right) + C_{2,3}\frac{D_{2,3}}{\mu_1}\left(\frac{\lambda_1\mu_1}{1-\lambda_1 \mu_1}\right)
+\dots\right)</script>

<p>As long as we can construct the transition matrices for the two sequences of coin tosses and get their eigen values and eigen matrices, we can
get the probability that one of them will beat the other using the approach above.</p>

<h2 id="7-other-methods">7. Other methods</h2>
<p>I alluded earlier that once you climb a mountain, you’ll sometimes see other mountains on the other side. But there are probably multiple paths 
to the top of the mountain you currently on. And climbing via another paths is probably a unique experience in itself.</p>

<p>In this section, we’ll therefore consider some other methods to solve our original problem (what is the chance you get to three consecutive heads before
I get to two consecutive heads?).</p>

<h2 id="71-a-different-equation">7.1. A “different” equation</h2>

<p>There is a way to tame these processes coming from a completely different direction. By constructing a difference equation 
(see what I did there? Anyone? Anyone?). Ok, it might be too early for that pun if you haven’t heard of difference equations before.</p>

<p>Here is how this goes - consider my sequence of tosses where I’m aiming for two consecutive heads.</p>

<p>Let’s see if there is an alternate way to get the sequence of probabilities <script type="math/tex">P_n</script> used in equation (3). In particular, let <script type="math/tex">a_n</script>
be the probability that I’ll reach my goal on the <script type="math/tex">n</script>th toss.</p>

<p>One thing we can say is that at the time when I reach my goal on the <script type="math/tex">n</script>th toss, the last two tosses I saw would have both been heads. 
Also, the third-from-final toss would have had to be a tails (otherwise, I would have won one toss earlier). The probability of this sequence
of THH is <script type="math/tex">\frac{1}{2}\times \frac{1}{2} \times \frac{1}{2} = \frac{1}{8}</script>.</p>

<p>Before these three tosses, my probability of winning would have been by definition, <script type="math/tex">a_{n-3}</script>. But if I am to win in the <script type="math/tex">n</script>th toss,
I need to exclude that event. And similarly <script type="math/tex">a_{n-4}</script> and so on. This means:</p>

<script type="math/tex; mode=display">a_n=\frac{1}{8}\left(1-\sum_{i=2}^{n-3} a_i\right) = \frac{1}{8}\left(1-\sum_{i=1}^{n-3} a_i\right)</script>

<p>The second part of the equality follows since <script type="math/tex">a_1 = 0</script> (the probability of reaching two consecutive heads on the first toss is zero).</p>

<p>Now let’s define:</p>

<script type="math/tex; mode=display">b_n = \sum_{i=1}^{n} a_i</script>

<p>which represents the probability you would have won by the <script type="math/tex">n</script>th toss.</p>

<p>Plugging this equation into the previous one we get:</p>

<script type="math/tex; mode=display">b_n-b_{n-1} = \frac{1}{8}(1-b_{n-3})</script>

<p>This is what I meant by “difference equation” it expresses a relationship for the difference of two consecutive terms of the series.</p>

<p>Simplifying further:</p>

<p>\begin{equation} b_n =  b_{n-1} - \frac{1}{8} b_{n-3} + \frac{1}{8} \tag{9}\end{equation}</p>

<p>Now, we know <script type="math/tex">b_n</script> for the first few values of <script type="math/tex">n</script>. When <script type="math/tex">n=0</script>, there is no way I would be in my absorbing state of two consecutive tosses. Hence, <script type="math/tex">b_0 = 0</script>. Even on the first toss, there is no chance I would have tosses two heads surely. So, <script type="math/tex">b_1=0</script> as well. When <script type="math/tex">n=2</script>, there is a chance I would see two consecutive heads. For that, the first two tosses would have to both have been heads. The probability of this event is <script type="math/tex">\frac{1}{2}\times\frac{1}{2} = 0.25</script>.</p>

<p>Now, we can use these and equation (9) to calculate the other terms of the sequence.</p>

<script type="math/tex; mode=display">b_3 = b_2 - \frac{b_0}{8} + \frac{1}{8} = 0.25 + 0.125 = 0.375</script>

<script type="math/tex; mode=display">b_4 = b_3 - \frac{b_1}{8} + \frac{1}{8} = 0.375 + 0.125 = 0.5</script>

<script type="math/tex; mode=display">b_5 = b_4 - \frac{b_2}{8} + \frac{1}{8} = 0.5+\frac{0.75}{8} = 0.59375</script>

<script type="math/tex; mode=display">\vdots</script>

<p>You get the idea by now, we can extend this as far as we like to get any <script type="math/tex">b_n</script>. This is an alternate way to get the sequence 
we calculated in section 3 (<script type="math/tex">P_n[2]</script>) and used in section 4 to get the answer.</p>

<p>But, we still need to patiently iterate all the way to <script type="math/tex">n</script> starting from <script type="math/tex">n=3</script>. This is similar to the way we were patiently multiplying matrices in section 3 to get the sequence of probabilities. However, we found a way in section 6 to replace the iterative method for calculating the probability sequence with a more elegant closed form. Is there a way we can find a closed form for this difference equation as well?</p>

<h3 id="711-closed-form-for-the-difference-equation">7.1.1. Closed form for the difference equation</h3>

<p>The standard way to solve a difference equation like (9) is to separate into homogeneous and non-homogeneous parts, solve the homogeneous part using a polynomial guess and then make another guess for how the solution will need to be modified to make it compatible with the original, non-homogeneous equation.</p>

<p>First, let’s clean up equation (9) a bit:</p>

<p>\begin{equation}8b_{n}-8b_{n-1}+b_{n-3}=1\tag{10}\end{equation}</p>

<p>The homogeneous part of this equation is given by:</p>

<p>\begin{equation}8b_{n}-8b_{n-1}+b_{n-3}=0\tag{11}\end{equation}</p>

<p>Here, we make an educated guess (“<a href="https://en.wikipedia.org/wiki/Ansatz">ansatz</a>” in German - we will make two of these guesses in this section which can make some people feel uneasy. If that is so, skip to the next sub-section (7.1.2) where we solve the same equation in a ‘more systematic’ manner).</p>

<p>We suspect the solution to this homogeneous equation might be:</p>

<script type="math/tex; mode=display">b_n' = l^n</script>

<p>Substituting this into equation (11), we get the characteristic polynomial:</p>

<script type="math/tex; mode=display">8l^3-8l^2+1=0</script>

<p>The roots of which are given by <script type="math/tex">l=\frac{1-\sqrt{5}}{4}, \frac{1+\sqrt{5}}{4}, \frac{1}{2}</script></p>

<p>Notice that the <a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a>, <script type="math/tex">\phi</script> is given by <script type="math/tex">\phi = \frac{1+\sqrt 5}{2}</script> which means we can express the roots of the characteristic polynomial of the homogeneous equation as:</p>

<script type="math/tex; mode=display">l = \frac{\phi}{2}, \frac{1-\phi}{2}, \frac 1 2</script>

<p>Remeber we started off with the assumption that <script type="math/tex">b_n'=l^n</script>. This means that the following will all work for <script type="math/tex">b_n'</script>:</p>

<script type="math/tex; mode=display">b_n' = \left(\frac{\phi}{2}\right)^n</script>

<script type="math/tex; mode=display">b_n' = \left(\frac{1-\phi}{2}\right)^n</script>

<script type="math/tex; mode=display">b_n' = \left(\frac{1}{2}\right)^n</script>

<p>Meaning that any linear combination of these three solutions will also be a solution of equation (11). So in general,</p>

<p>\begin{equation}b_n’ = c_1 \left(\frac{\phi}{2}\right)^n + c_2 \left(\frac{1-\phi}{2}\right)^n + c_3 \left(\frac {1} {2}\right)^n\tag{12}\end{equation}</p>

<p>Now, how do we modify this solution of equation (11) above to get the solution of the original, non-homogeneous equation (equation (10))?</p>

<p>We know that <script type="math/tex">b_n'</script> satisfies equation (10) so we can write:</p>

<script type="math/tex; mode=display">8b_n'-8b_{n-1}'+b_{n-3}' = 0</script>

<p>Let’s assume <script type="math/tex">b_n' = b_n+c_0</script></p>

<p>So the equation above becomes:</p>

<script type="math/tex; mode=display">8(b_n+c_0)-8(b_n+c_0)+(b_{n-3}+c_0) = 0</script>

<script type="math/tex; mode=display">=>8b_n-8b_n+b_{n-3} = -c_0</script>

<p>To make this align with equation (10) we require <script type="math/tex">c_0=-1</script></p>

<p>And this would mean <script type="math/tex">b_n = b_n'-c_0 = b_n'+1</script></p>

<p>So, the general solution (<script type="math/tex">b_n</script>) of equation (10) can be written using this result and (12):</p>

<p>\begin{equation}b_n= c_1 \left(\frac{\phi}{2}\right)^n + c_2 \left(\frac{1-\phi}{2}\right)^n + c_3 \left(\frac {1} {2}\right)^n + 1\tag{13}\end{equation}</p>

<p>And for the two consecutive heads problem, we can use the first few values in the sequence <script type="math/tex">b_n</script> in particular, <script type="math/tex">b_0=0</script>, <script type="math/tex">b_1=0</script>, <script type="math/tex">b_2=0.25</script> and <script type="math/tex">b_3=0.375</script> to get the <script type="math/tex">c_i</script>’s. This is accomplished with the following python code:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">phi</span> <span class="o">=</span> <span class="mf">1.618033988749895</span>
<span class="c">## The three roots</span>
<span class="n">l1</span> <span class="o">=</span> <span class="n">phi</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">phi</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">l3</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>

<span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span>   <span class="n">l2</span><span class="p">,</span>   <span class="n">l3</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">l2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">l3</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span><span class="n">l2</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span><span class="n">l3</span><span class="o">**</span><span class="mi">3</span><span class="p">]])</span>

<span class="c">## The first four b_n's</span>
<span class="n">bn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">375</span><span class="p">])</span>
<span class="n">cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="n">bn</span><span class="p">)</span>
<span class="c"># cc is the vector of coefficients [c_0,c_1,c_2,c_3] = [1., -1.17082039, .170820393, 0]</span>
</code></pre>
</div>

<h3 id="712-closed-form-for-difference-equation-using-matrix-approach">7.1.2. Closed form for difference equation using matrix approach</h3>

<p>If you were happy with the solution presented in 7.1.1, you can skip this one.</p>

<p>But some people feel like that qpproach requires a lot of guessing. How am I supposed to make all the right guesses after all? So, let’s explore another method to solve the difference equation which is based on the eigen values of a matrix just like the method in section 6 was.</p>

<p>To get a matrix, we need a system of equations while we have only one (eqn 9). To create a system of equations, let’s just add two more dummy equations.</p>

<script type="math/tex; mode=display">b_{n-1}=b_{n-1}</script>

<script type="math/tex; mode=display">b_{n-2}=b_{n-2}</script>

<p>Now, we can combine the above two equations with equation (9) and express this system in matrix form.</p>

<script type="math/tex; mode=display">% <![CDATA[
\left( \begin{array}{c}
		b_n \\
		b_{n-1}\\
		b_{n-2}\\
		\end{array} \right) = \left( \begin{array}{ccc}
		1 & 0 & -\frac{1}{8} & \\
		1 & 0 & 0\\
		0 & 1 & 0\\
		\end{array} \right) \left( \begin{array}{c}
		b_{n-1} \\
		b_{n-2}\\
		b_{n-3}\\
		\end{array} \right) + \left( \begin{array}{c}
		\frac{1}{8} \\
		0\\
		0\\
		\end{array} \right) %]]></script>

<p>Now let <script type="math/tex">\beta_n = \left(\begin{array}{c}
		b_n \\
		b_{n-1}\\
		b_{n-2}\\
		\end{array} \right)</script>, <script type="math/tex">\gamma = \left(\begin{array}{c}
		\frac{1}{8} \\
		0\\
		0\\
		\end{array} \right)</script> and <script type="math/tex">% <![CDATA[
M = \left( \begin{array}{ccc}
		1 & 0 & -\frac{1}{8} & \\
		1 & 0 & 1\\
		0 & 1 & 0\\
		\end{array} \right) %]]></script>.</p>

<p>We then get:</p>

<script type="math/tex; mode=display">\beta_n = M \beta_{n-1} + \gamma</script>

<script type="math/tex; mode=display">=M(M \beta_{n-2}+\gamma) + \gamma</script>

<script type="math/tex; mode=display">=M^2 \beta_{n-2} + (I+M)\gamma</script>

<script type="math/tex; mode=display">=M^3 \beta_{n-3} + (I+M+M^2)\gamma</script>

<script type="math/tex; mode=display">\vdots</script>

<p>And repeating this <script type="math/tex">(n-2)</script> times we get,</p>

<script type="math/tex; mode=display">\beta_n = M^{n-2}\beta_{2} + (I+M+M^2+ \dots + M^{n-3})\gamma</script>

<p>Now, assuming <script type="math/tex">M</script> is diagonalizable (which it is) we can say:</p>

<script type="math/tex; mode=display">M=E\Lambda E^{-1}</script>

<p>And this would imply:</p>

<script type="math/tex; mode=display">M^n = E \Lambda^n E^{-1}</script>

<p>So we get:</p>

<p>\begin{equation}\beta_n = E\Lambda^{n-2}E^{-1}\beta_2 + E(I+\Lambda+\Lambda^2+\dots+\Lambda^{n-3})E^{-1}\gamma \tag{14}\end{equation}</p>

<p>Now, if <script type="math/tex">\lambda_1</script>, <script type="math/tex">\lambda_2</script> and <script type="math/tex">\lambda_3</script> happen to be the eigen values of <script type="math/tex">M</script> then,</p>

<script type="math/tex; mode=display">% <![CDATA[
\Lambda = \left( \begin{array}{ccc}
		\lambda_1 & 0 & 0 \\
		0 & \lambda_2 & 0 \\
		0 & 0 & \lambda_3 \\
		\end{array} \right) %]]></script>

<p>and,</p>

<script type="math/tex; mode=display">% <![CDATA[
\Lambda \Lambda = \Lambda^2 = \left( \begin{array}{ccc}
		\lambda_1^2 & 0 & 0 \\
		0 & \lambda_2^2 & 0 \\
		0 & 0 & \lambda_3^2 \\
		\end{array} \right) %]]></script>

<p>meaning the <script type="math/tex">\Lambda</script> stays diagonal no matter how many times we multiply it with itself.</p>

<p>Remember, we are interested in the first element of <script type="math/tex">\beta_n</script> which is <script type="math/tex">b_n</script> and can be extracted by taking a dot product with a vector that has a 1 in the first position and zero at other positions.</p>

<script type="math/tex; mode=display">b_n = \beta_n^T \left(\begin{array}{c}1 \\ 0 \\ 0\\\end{array} \right)</script>

<p>Now, using the same arguments as in section 6, we can say that any component of the first term in the R.H.S of equation (14) can be written as:</p>

<script type="math/tex; mode=display">(E \Lambda^{n-2} E^{-1} \beta_2)^T \left(\begin{array}{c}1 \\ 0 \\ 0\\\end{array} \right) = l_1 \lambda_1^{n-2}+l_2 \lambda_2^{n-2} + l_3 \lambda_3^{n-2} \tag{15}</script>

<p>Now to tackle the second term of equation (14). Observe that:</p>

<script type="math/tex; mode=display">% <![CDATA[
(I+\Lambda+\Lambda^2 + \dots + \Lambda^{n-3}) = 
		\left( \begin{array}{ccc}
			1+\lambda_1+\dots+\lambda_1^{n-3} & 0 & 0 \\
			0 & 1+\lambda_2+\dots+\lambda_2^{n-3} & 0 \\
			0 & 0 & 1+\lambda_3+\dots+\lambda_3^{n-3} \\
		\end{array} \right) %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
= \left( \begin{array}{ccc}
			\frac{1-\lambda_1^{n-2}}{1-\lambda_1} & 0 & 0 \\
			0 & \frac{1-\lambda_2^{n-2}}{1-\lambda_2} & 0 \\
			0 & 0 & \frac{1-\lambda_3^{n-2}}{1-\lambda_3} \\
		\end{array} \right) %]]></script>

<p>Here, we used the geometric series result:</p>

<script type="math/tex; mode=display">1+\lambda + \lambda^2 + \dots + \lambda^{n-1} = \frac{1-\lambda^n}{1-\lambda}</script>

<p>Again, we see a similar pattern to the one utilized in equation (15) and so we can say:</p>

<script type="math/tex; mode=display">% <![CDATA[
(E(I+\Lambda+\Lambda^2+\dots+\Lambda^{n-3})E^{-1}\gamma)^T \left(\begin{array}{c}1 \\ 0 \\ 0\\\end{array} \right) = 
\left(\begin{array}{ccc}1&0&0\end{array}\right)
E \left( \begin{array}{ccc}
			\frac{1-\lambda_1^{n-2}}{1-\lambda_1} & 0 & 0 \\
			0 & \frac{1-\lambda_2^{n-2}}{1-\lambda_2} & 0 \\
			0 & 0 & \frac{1-\lambda_3^{n-2}}{1-\lambda_3} \\
		\end{array} \right)E^{-1}\gamma %]]></script>

<script type="math/tex; mode=display">= m_1 \frac{1-\lambda_1^{n-2}}{1-\lambda_1} + m_2 \frac{1-\lambda_2^{n-2}}{1-\lambda_2} + m_3 \frac{1-\lambda_3^{n-2}}{1-\lambda_3}</script>

<p>meaning,</p>

<script type="math/tex; mode=display">(E(I+\Lambda+\Lambda^2+\dots+\Lambda^{n-3})E^{-1}\gamma)^T \left(\begin{array}{c}1 \\ 0 \\ 0\\\end{array} \right)</script>

<script type="math/tex; mode=display">= 
\left(\frac{m_1}{1-\lambda_1} + \frac{m_2}{1-\lambda_2} + \frac{m_3}{1-\lambda_3}\right)
- \left(\frac{m_1}{1-\lambda_1} \lambda_1^{n-2} + \frac{m_2}{1-\lambda_2} \lambda_2^{n-2} + \frac{m_3}{1-\lambda_3} \lambda_3^{n-2}\right)</script>

<script type="math/tex; mode=display">= d_0 + d_1 \lambda_1^{n-2} + d_2 \lambda_2^{n-2} + d_3 \lambda_3^{n-2} \tag{16}</script>

<p>Adding equations (15) and (16), we get the first term in the L.H.S of equation (14), which is <script type="math/tex">b_n</script>.</p>

<script type="math/tex; mode=display">b_n = \beta_n^T\left(\begin{array}{c}1\\0\\0\end{array}\right)</script>

<script type="math/tex; mode=display">= (E\Lambda^{n-2}E^{-1}\beta_2 + E(I+\Lambda+\Lambda^2+\dots+\Lambda^{n-3})E^{-1}\gamma)^T \left(\begin{array}{c}1\\0\\0\end{array}\right)</script>

<script type="math/tex; mode=display">= d_0 + (d_1+l_1)\lambda_1^{n-2} + (d_2+l_2) \lambda_2^{n-2} + (d_3+l_3) \lambda_3^{n-2}</script>

<p>Now redefine: <script type="math/tex">c_0 = d_0</script>, <script type="math/tex">\frac{d_1+l_1}{\lambda_1^2} = c_1</script> and so on we get:</p>

<script type="math/tex; mode=display">b_n = c_0 + c_1 \lambda_1^n + c_2 \lambda_2^n + c_3 \lambda_3^n</script>

<p>Now, the eigen values of <script type="math/tex">M</script> are: <script type="math/tex">\lambda_1, \lambda_2, \lambda_3 = \frac{\phi}{2}</script>, <script type="math/tex">\frac{1-\phi}{2}</script>, <script type="math/tex">\frac 1 2</script>, which are the same as the roots of the polynomial equation in the previous sub-section.</p>

<p>Substituting this into the previous equation we get equation (13) through this alternate linear algebra based route.</p>

<h2 id="72-ill-give-you-the-answer-on-one-condition">7.2. I’ll give you the answer on one condition</h2>

<p>We started this blog with a simple to understand problem. The solution provided involved Markov chains and thinking in terms of states.
That solution was like a silver bullet for a whole family of problems of this nature. In this section, we will pursue a simpler solution that involves just conditional probabilities.</p>

<p>Let’s define <script type="math/tex">A</script> as the event that you win.</p>

<p>Now, instead of thinking about the entire sequences of tosses, let’s think of just the very first toss for both sequences (the top one is yours and the bottom one is mine). Conditioning on these first two tosses we get,</p>

<script type="math/tex; mode=display">P(A) = P\left(\begin{array}{c}
		 H \\
		 H 
		\end{array} \right) P\left(A| \begin{array}{c}
		 H \\
		 H 
		\end{array} \right) + P\left(\begin{array}{c}
		 H \\
		 T 
		\end{array} \right) P\left(A| \begin{array}{c}
		 H \\
		 T
		\end{array} \right)</script>

<script type="math/tex; mode=display">+P\left(\begin{array}{c}
		 T \\
		 H  
		\end{array} \right) P\left(A| \begin{array}{c}
		 T  \\
		 H  
		\end{array} \right) + P\left(\begin{array}{c}
		 T \\
		 T 
		\end{array} \right) P\left(A| \begin{array}{c}
		 T \\
		 T 
		\end{array} \right)</script>

<p>Now, since all tosses are independent,</p>

<script type="math/tex; mode=display">P\left(\begin{array}{c}
		 T \\
		 H 
		\end{array} \right) = P\left(\begin{array}{c}
		 H \\
		 T 
		\end{array} \right) = P\left(\begin{array}{c}
		 H \\
		 H 
		\end{array} \right) = P\left(\begin{array}{c}
		 T \\
		 T 
		\end{array} \right) = \frac 1 4</script>

<p>Which means that:</p>

<script type="math/tex; mode=display">P(A) = \frac 1 4 P\left(A| \begin{array}{c}
		 H  \\
		 H  
		\end{array} \right) + \frac 1 4 P\left(A| \begin{array}{c}
		 H \\
		 T
		\end{array} \right)</script>

<script type="math/tex; mode=display">+\frac 1 4 P\left(A| \begin{array}{c}
		 T \\
		 H 
		\end{array} \right) + \frac 1 4 P\left(A| \begin{array}{c}
		 T \\
		 T 
		\end{array} \right)</script>

<p>Now, if both of us get tails on our first tosses, that’s essentially the same as restarting the game. We might as well throw those tosses out and start from scratch since none of us is any closer to their goal.</p>

<p>Therefore its easy to see that:</p>

<script type="math/tex; mode=display">P\left(A| \begin{array}{c}
		 T \\
		 T  
		\end{array} \right)  = P(A)</script>

<p>Substituting into the previous equation we get:</p>

<script type="math/tex; mode=display">P(A) = \frac 1 3 \left(P\left(A| \begin{array}{c}
		 H \\
		 H 
		\end{array} \right) +  P\left(A| \begin{array}{c}
		 H \\
		 T
		\end{array} \right) +  P\left(A| \begin{array}{c}
		 T \\
		 H 
		\end{array} \right) \right) \tag{17}</script>

<p>Now let’s tackle the next term in order of difficulty, <script type="math/tex">P\left(A| \begin{array}{c}
		 T \\
		 H 
		\end{array} \right)</script>. Let’s consider the various possibilities.</p>

<ul>
  <li>If I get a tails on the next toss, the game is over and I’ve won. So, I <em>have</em> to get a tails on my second toss for you to win (or event <script type="math/tex">A</script> to occur). The probability of this is <script type="math/tex">\frac 1 2</script>. The question becomes, what did you get on your second toss.
    <ul>
      <li>Now if you get a tails on the second toss (an event with probability <script type="math/tex">\frac 1 2</script>), the game would have been reset and the probability of you winning from there is <script type="math/tex">P(A)</script>.</li>
      <li>If you get a heads on your next toss, then we can throw away the first tosses. The probability you will win from here becomes <script type="math/tex">P\left(A| \begin{array}{c}
   H \\
   T 
  \end{array} \right)</script></li>
    </ul>
  </li>
</ul>

<p>Putting all this together we get -</p>

<script type="math/tex; mode=display">P\left(A| \begin{array}{c}
		 T \\
		 H 
		\end{array} \right) = \frac 1 2 \left[ \frac{1}{2} P(A) + \frac 1 2 P\left(A| \begin{array}{c}
		 H \\
		 T 
		\end{array} \right)  \right] \tag{18}</script>

<p>Next, let’s tackle <script type="math/tex">P\left(A| \begin{array}{c}
		 H \\
		 H 
		\end{array} \right)</script>.</p>

<ul>
  <li>If I get a heads on the second toss, the game is over since my first toss was already a heads. So, we don’t have to consider any possibility where that happens. So, our next two tosses can either be a heads for you and tails for me or tails for both of us.
    <ul>
      <li>If the our second tosses result in a heads for you and tails for me, the probability of this is <script type="math/tex">\frac 1 4</script>.
        <ul>
          <li>If you then score a heads on the third toss as well (probability <script type="math/tex">\frac 1 2</script>), you win and it doesn’t matter what I got.</li>
          <li>If you score a tails (probability <script type="math/tex">\frac 1 2</script>), things get more interesting.
            <ul>
              <li>If I score a heads (probability <script type="math/tex">\frac 1 2</script>), it’s effectively the same as me being on one heads and you being a one tails, which is <script type="math/tex">P\left(A| \begin{array}{c}
   		T \\
   			H 
  \end{array} \right)</script>.</li>
              <li>If I score a tails (probability <script type="math/tex">\frac 1 2</script>), then we both scored tails on our third tosses and any time that happens the game resets and the probability of you winning again becomes <script type="math/tex">P(A)</script>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>If I get a tails on the second toss (probability <script type="math/tex">\frac 1 2</script>), it means we now both have tails and the game has reset. So the probability from here is <script type="math/tex">P(A)</script>.</li>
    </ul>
  </li>
</ul>

<p>Putting all this together we have:</p>

<script type="math/tex; mode=display">P\left(A| \begin{array}{c}
		 H \\
		 H 
		\end{array} \right) = \frac 1 4 \left( \frac 1 2 + \frac 1 2 \left( \frac 1 2 P\left(A| \begin{array}{c}
		 T \\
		 H 
		\end{array} \right) + \frac 1 2 P(A)\right)\right) + \frac 1 4 P(A)\tag{19}</script>

<p>And using similar reasoning we can get:</p>

<script type="math/tex; mode=display">P\left(A| \begin{array}{c}
		 H \\
		 T 
		\end{array} \right) = \frac 1 4 \left( \frac 1 2 + \frac 1 2 \left(\frac 1 2 P(A) + \frac 1 2 P\left(A| \begin{array}{c}
		 T \\
		 H 
		\end{array} \right)\right) \right)</script>

<script type="math/tex; mode=display">+ \frac 1 4 \frac 1 2 \left(\frac 1 2 + \frac 1 2 P(A)\right) + \frac 1 4 P\left(A| \begin{array}{c}
		 T \\
		 H 
		\end{array} \right) + \frac 1 4 P(A)\tag{20}</script>

<p>Now, equations (17), (18), (19) and (20) are four equations in four unknowns and they can be solved to get <script type="math/tex">P(A)</script>, which happens to be one of those unknowns.</p>

<h2 id="73-one-big-chain">7.3. One big chain</h2>

<p>The original problem stated in this blog (you get three consecutive heads before I get two consecutive heads) was solved using Markov chains.</p>

<p>Is the fact then that there exists another method to solve this same problem, also relying completely on Markov chains,
but having very little to do with the one discussed in section 4 a testement to the versetility and power of Markov chains?</p>

<p>Let’s go over this new method before we decide.</p>

<p>Here, instead of keeping track of the two coin toss sequences independently of each other, we define a single state for the whole game.</p>

<p>And this state is a collection of two numbers, the number of consecutive heads seen so far by you and me (first number, second number).</p>

<p>Before any of us tosses our coin, the state is of course <script type="math/tex">(0,0)</script>. After the first toss, if I get a heads and you get a tails, 
the state will be <script type="math/tex">(1,0)</script>; if both of us get heads, it will be <script type="math/tex">(1,1)</script> and so on.</p>

<p>Also like the markov chains in the method described in section 4, we can’t let this one have an unbounded number of states. We need
to stunt it’s state space by defining the ones that lead to a victory for either you or I as absorbing states. So for example, it will
be impossible to get to state <script type="math/tex">(4,1)</script> since you would have won and hence stopped as soon as you got three consecutive heads, hence never reaching four.</p>

<p>This makes <script type="math/tex">(3,0)</script> and <script type="math/tex">(3,1)</script> absorbing states that result in your victory while <script type="math/tex">(0,2)</script>, <script type="math/tex">(1,2)</script>, <script type="math/tex">(2,2)</script> and even <script type="math/tex">(3,2)</script> absorbing states resulting in my victory (you need to get 3 consecutive heads <em>before</em> I get two consecutive heads).</p>

<p>So, the possible states are (might as well express them in python code):</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">index2state</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
</code></pre>
</div>

<p>Note that for the first six states, none of us has won. These are called transient states since they go to other states.</p>

<p>In the last six states, one of us has won and once the game reaches them, it stays in those states forever (since it concluded as soon as it reached them). Those states are called recurrent states.</p>

<p>Of the six recurrent states ((0,2),(1,2),(2,2),(3,0),(3,1) and (3,2)); (3,0) and (3,1) are the only ones where you win.</p>

<p>Now, the rules of the game obviously dictate some transition matrix between the states mentioned above.</p>

<ul>
  <li>Any time the game is in state (i,j), if (i,j) is a transient state:
    <ul>
      <li>It will transition to (0,0) if both of us get heads (probability <script type="math/tex">\frac 1 4</script>).</li>
      <li>It will transition to (i+1,0) if you get a heads but I get a tails (probability <script type="math/tex">\frac 1 4</script>).</li>
      <li>It will transition to (j+1,0) if you get a tails and I get a heads (probability <script type="math/tex">\frac 1 4</script>).</li>
      <li>It will transition to (i+1,j+1) if both of us get heads (probability <script type="math/tex">\frac 1 4</script>).</li>
    </ul>
  </li>
  <li>Any time the game is in an absorbing state, it stays in the absorbing state with probability 1.</li>
</ul>

<p>The matrix these rules correspond to is shown in the figure below. The transient states are represented in black, the absorbing states where you lose are represented in red and the ones where you win in green.</p>

<p>The larger matrix is divided into four sections. The top-left section is the sub-matrix for transitions between transient states. We call it <script type="math/tex">Q</script>. The top-right is the sub-matrix for transitions from transient to recurring states. We call it <script type="math/tex">R</script>. The bottom right is from recurring to recurring. Since recurring states stay in the same state and don’t transition anywhere else, this is simply an identity matrix.</p>

<p><img src="http://localhost:4000/Downloads/CompetitiveCoinToss/BigMatrix.png" alt="Probability sequences" /></p>

<p>Now, if we can find the probabilities that the game ends in each of the recurring states, we can use those to find the probability you’ll win since the recurring states corresponding to your victory are (3,0) and (3,1).</p>

<p>Given that we start in transient state <script type="math/tex">i</script>, the probabilities that the game ends up in each of the absorbing states is given by the <script type="math/tex">i</script>th row of the matrix given by:</p>

<script type="math/tex; mode=display">U = (I-Q)^{-1}R \tag{21}</script>

<p>To see the reason, conditionin the absorption process from state <script type="math/tex">i</script> to state <script type="math/tex">j</script> based on what happens in the first transition: either the absorption happens in the first transition with probability <script type="math/tex">R_{ij}</script>, or a transition occurs into some other transient state <script type="math/tex">k</script> with probability <script type="math/tex">Q_{ik}</script> and from there transitions until eventually absorbed with probability <script type="math/tex">u_{kj}</script>. This can be expressed as the matrix equation</p>

<script type="math/tex; mode=display">u = Qu + R</script>

<p>where solving for <script type="math/tex">u</script> generates the original equation above.</p>

<p>Here is some python code that generates the transition matrix <script type="math/tex">M</script> shown in the figure above, splits it into <script type="math/tex">Q</script> and <script type="math/tex">R</script> and then uses them to obtain <script type="math/tex">U</script> as per equation (21).</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">))</span>
<span class="n">state2index</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">0</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">1</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">2</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">3</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">4</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">5</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">6</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">7</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">8</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span><span class="mi">9</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="mi">10</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">11</span><span class="p">}</span>
<span class="n">index2state</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">state2index</span><span class="p">[(</span><span class="n">index2state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]]</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">state2index</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">index2state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]]</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">state2index</span><span class="p">[(</span><span class="n">index2state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">index2state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]]</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="n">m</span><span class="p">[</span><span class="mi">6</span><span class="p">:,</span><span class="mi">6</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">m</span><span class="p">[:</span><span class="mi">6</span><span class="p">,:</span><span class="mi">6</span><span class="p">]</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">[:</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">:]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">-</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Probability you win:"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
</code></pre>
</div>

<!---
$$
M =
\left( \begin{array}{cccccccccccc}
		0.25 & 0.25 & 0.25 & 0. &  0.25 & 0.25 & 0.25 & 0. & 0. & 0. & 0. & 1. \\
		0.25 & 0. & 0. & 0. &  0.25 & 0. &  0. & 0. & 0. & 0. &  0. & 0. \\
		0. &  0.25 & 0. &  0. &  0. &  0.25 & 0. &  0. &  0. &  0. &  0. &  0. \\
		0. &  0. &  0.25 &  1. &  0. &  0. &  0.25 &  0. &  0. &  0. &  0. &  0. \\
		0.25 & 0.25 & 0.25 & 0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. \\
		0.25 & 0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. \\
		0. &  0.25 & 0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. &  0. \\
		0. &  0. &  0.25 & 0. &  0. &  0. &  0. &  1. &  0. &  0. &  0. &  0. \\
		0. &  0. &  0. &  0. &  0.25 & 0.25 & 0.25 & 0. &  1. &  0. &  0. &  0. \\ 
		0. & 0. & 0. & 0. & 0.25 & 0. & 0. & 0. & 0. & 1. & 0. & 0. \\
 		0. & 0. & 0. & 0. & 0. & 0.25 & 0. & 0. & 0. & 0. & 1. & 0.  \\
        0. & 0. & 0. & 0. & 0. & 0. & 0.25 & 0. & 0. & 0. & 0. & 0. \\
		\end{array} \right)
$$

$$
\left( \begin{array}{ccc}
	\underline{-}| & \underline{a} & \underline{b}  \\
	a| & 0 & 1 \\
	b| & 0 & 1 \\
\end{array} \right)
$$

## 7.4. Without a computer
**Note: This section is under construction**

Let's say this question was posed to you while you we're on vacation, sitting somewhere on a beach. Ghastly as that prospect is,
would we have some means of solving it with an advanced stick to draw on the sand with? Or is reaching for some kind of modern computer
your only option?

Unfortunately, I don't know a way to get the exact answer without a computer. If you do, please leave a comment. But, I know how to
do the next best thing - get upper and lower bounds on the probabilitiy.

Since the premise of this section is that you don't have access to a computer, all the calculations shown in this section can be carried
out on a pen and paper (or stick and sand).
-->


  </div>
  
  
    
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://ryu577.github.io/jekyll/update/2018/10/07/competitive_coin_tossing.html"; // <--- use canonical URL
this.page.identifier = "/jekyll/update/2018/10/07/competitive_coin_tossing";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//github-io-2.disqus.com/embed.js'; // <--- use Disqus shortname

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Musings on Math (++)</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Musings on Math (++)
            
            </li>
            
            <li><a href="mailto:rohitpandey576 _at_ gmail">rohitpandey576 _at_ gmail</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ryu577"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ryu577</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/rohitpandey576"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">rohitpandey576</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>I write here about Math and other topics.
</p>
      </div>
    </div>

  </div>

</footer>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  //ga('create', '', 'auto');
  ga('create', 'UA-92632279-1', 'auto');
  ga('send', 'pageview');

</script>
  

  </body>

</html>
